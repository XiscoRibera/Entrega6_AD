---
title: "Cirrosis"
title-slide-attributes:
    data-background-image: higado.jpeg
    data-background-size: contain
    data-background-opacity: "1"
format: 
  revealjs:
    #smaller: FALSE
    scrollable: TRUE
    transition: 'slide' # 'slide', 'fade', 'convex', 'concave', 'zoom', etc.
editor: visual
author: Irene LiFeng Julià Pérez & Xisco Ribera Ramis
include-in-header:
  - text: |
      <style>
      #title-slide .title {
        font-size: 5.5em;
        color: #b22222;
        text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.8);
        margin-top: 100px;
      }
      .reveal p {
        font-size: 0.7em;
      }
      </style>
---


```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(dplyr)
library(GGally)
library(psych)
library(skimr)
library(fmsb)
library(mvnormtest)
library(car)
library(nortest)
library(fBasics)
library(ggplot2)
library(factoextra)
library(stats)
library(cluster)
library(NbClust)
library(ggrepel)
library(tidyverse)
library(dplyr)
library(knitr)
library(kableExtra)
```


### Presentación del problema

<span style="font-size: 0.8em;">

-   Base de datos relacionados con la cirrosis.

-   Fuente: [Kaggle - Cirrhosis](https://www.kaggle.com/datasets/fedesoriano/cirrhosis-prediction-dataset/)

-   Repositorio: [enlace](https://github.com/XiscoRibera/Entrega6_AD.git)

<div>

<p style="text-align:center;">

</span>



<center>

<img src="Foto_cirrosis.jpg" width="700px"/>

</center>

</p>

</div>

## 


### Objetivo del estudio

Establecer un perfil de paciente para cada fase de la cirrosis utilizando clustering.

<div>

<p style="text-align:center;">

<center>

<img src="Foto2.jpg" width="600px"/>

</center>

</p>

</div>

## {.smaller}

Cargamos los datos y arreglamos las variables:

```{r, echo=TRUE}
datos <- read.table("cirrosis_tidy.csv",  header = TRUE )
datos = datos %>% mutate(Ascites = Ascites %>% as.factor,
                         Hepatomegaly = Hepatomegaly %>% as.factor,
                         Spiders = Spiders %>% as.factor,
                         Edema = Edema %>% as.factor,
                         Stage = Stage %>% as.factor,
                         Drug = Drug %>% as.factor,
                         Sex = Sex %>% as.factor,
                         Status = Status %>% as.factor)
```



```{r}
glimpse(datos)
```

## 

### Variables

#### Variables cuantitativas

```{r, echo=FALSE}
# Separamos los datos en variables cuantitativas y cualitativas
datos_quant <- datos %>% 
  select(where(is.numeric)) %>% 
  select(-1)


datos_qual <- datos %>% 
  select(where(is.factor))


# Cuantitativas

Unidad = c("Días", "Días", "mg/dl", "mg/dl", "g/dl", "ug/día", "U/l", "U/ml", "mg/dl", "ml/1000", "s")

Media = round(colMeans(datos_quant),3)

rango <- function(x){
  return(max(x)-min(x))
}
Rango = round(apply(datos_quant, FUN = rango, MARGIN = 2), 3)
Minimo = round(apply(datos_quant, FUN = min, 2),3)
Maximo = round(apply(datos_quant, FUN = max, 2),3)
Desv = round(apply(datos_quant, FUN = sd, 2), 3)

tabla = data.frame(Unidad, Media, Desv, Minimo, Maximo, Rango)

kable(tabla, format = "html", escape = FALSE) %>%
  kable_styling("striped", full_width = TRUE) %>%
  kable_styling(font_size = 25)  # Ajusta el tamaño de la fuente
```

## 

#### Variables cualitativas

```{r, echo=FALSE}
summary(datos_qual)
```


# Clustering



Vamos a escoger los datos cuantitativos y los valos a escalar.

```{r, echo=TRUE}
datos2 <- datos_quant %>% scale()
```


A continuación, los centramos.

```{r, echo=TRUE}
n <- dim(datos2)[1]
X <- as.matrix(datos2)
Hn <- diag(n)-1/n # matriz de centrado
cX <- Hn%*%X # matriz centrada
```


##

### Matriz de distancias


```{r}
mat_dist <- dist(x = cX, method = "euclidean")
```

```{r, cache = TRUE}
fviz_dist(dist.obj = mat_dist, lab_size = 5) +
 theme(legend.position = "none")
```



## K-means

En nuestro caso, no sabemos en cuantos clusters o grupos esta dividido nuestro dataset. Por tanto, vamos a estimar al número $k$ óptimo para aplicar el método de `kmeans()`:

```{r}
fviz_nbclust(x = cX, FUNcluster = kmeans, method = "wss",
 diss = dist(cX, method = "euclidean"))+
  geom_vline(xintercept = 4, linetype = 2)
```



##

Vamos a calcular los 4 centroides con nuestros datos y con 30 iteraciones.

```{r}
set.seed(232)
km_clusters_4 <- kmeans(x = cX, centers = 4, nstart = 70)
```


Representamos dichos clusters en el plano, utilizando las 2 primeras componentes principales:

```{r}
fviz_cluster(object = km_clusters_4, data = cX, show.clust.cent = TRUE, geom ="point",
 ellipse.type = "euclid", star.plot = TRUE, repel = TRUE, palette = c("#FF7078", "#F39B4C", "#7FBFF5", "#A298E8")) +
theme_bw() +
theme(legend.position = "right")
```


##

Sería interesante ver si estos clusters corresponden a las fases de cirrosis segun la variable `stage`. Veamos la tabla de frecuencias:


<center>
<img src="tabla_freqs.png" width="300px"/>
</center>


Un kmeans con $k=4$ no clusteriza en función del estado de cirrosis en que se encuentra el paciente.








