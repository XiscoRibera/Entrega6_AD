---
title: "Clustering"
author: "Xisco Ribera & Irene Julià"
format:
  html:
    toc: true
    toc-depth: 5
editor: visual
---

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(dplyr)
library(GGally)
library(psych)
library(skimr)
library(fmsb)
library(mvnormtest)
library(car)
library(nortest)
library(fBasics)
library(ggplot2)
library(factoextra)
library(stats)
library(cluster)
```


# Recordatorio

Vamos a tratar una base de datos relacionados con la predicción de riesgo de cirrosis. La cirrosis es una etapa tardía de la cicatrización (fibrosis) del hígado causada por muchas formas de enfermedades y afecciones hepáticas, como la hepatitis y el alcoholismo crónico.

Nuestro objetivo para este estudio sería estudiar algunos perfiles con riesgo de padecer cirrosis.

Recordemos nuestra tabla de datos:

```{r}
datos <- read.table("cirrosis_tidy.csv",  header = TRUE )
datos = datos %>% mutate(Ascites = Ascites %>% as.factor,
                         Hepatomegaly = Hepatomegaly %>% as.factor,
                         Spiders = Spiders %>% as.factor,
                         Edema = Edema %>% as.factor,
                         Stage = Stage %>% as.factor,
                         Drug = Drug %>% as.factor,
                         Sex = Sex %>% as.factor,
                         Status = Status %>% as.factor)


glimpse(datos)
```
El tibble resultante consta de 276 observaciones y 20 variables. Cada muestra representa un paciente al que se le ha extraido la siguiente información:

-   `ID`: Identificador único
-   `N_Days`: Número de días entre el registro y la fecha de defunción, transplante o estudio analítico enJulio de 1986.
-   `Status`: Estatus del paciente: C (Censurado), CL (censurado debido a tratamiento hepático), o D (Muerto)
-   `Drug`: Tipo de fármaco: D-penicilamina o placebo
-   `Age`: Edad \[días\]
-   `Sex`: Sexo cromosómico: Male (hombre) o Female (Mujer)
-   `Ascites`: Presencia de Ascitis No o Si
-   `Hepatomegaly`: Presencia de Hepatomegalia No o Si
-   `Spiders`: Presencia de arañas vasculares No o Si
-   `Edema`: Presencia de Edema: No (no hay edema y sin tratamiento diurético para el edema), Sin (presencia de edema sin diuréticos, o edema curado con diuréticos), o Si (edema a pesar del tratamiento con diuréticos)
-   `Bilirubin`: Bilirrubina sérica \[mg/dl\]
-   `Cholesterol`: Colesterol sérico \[mg/dl\]
-   `Albumin`: Albúmina \[g/dl\]
-   `Copper`: Cobre en orina \[ug/day\]
-   `Alk_Phos`: Fosfatasa alcalina \[U/liter\]
-   `SGOT`: SGOT \[U/ml\]
-   `Triglycerides`: Triglicéridos \[mg/dl\]
-   `Platelets`: Plaquetas por cúbico \[ml/1000\]
-   `Prothrombin`: Tiempo de Protrombina \[s\]
-   `Stage`: Estado histórico de la enfermedad (1, 2, 3, or 4)

## Resumen numérico de las variables

- Datos cuantitativos:

```{r, echo=FALSE}
# Separamos los datos en variables cuantitativas y cualitativas
datos_quant <- datos %>% 
  select(where(is.numeric)) %>% 
  select(-1)


datos_qual <- datos %>% 
  select(where(is.factor))


# Cuantitativas

Unidad = c("Días", "Días", "mg/dl", "mg/dl", "g/dl", "ug/día", "U/l", "U/ml", "mg/dl", "ml/1000", "s")

Media = round(colMeans(datos_quant),3)

rango <- function(x){
  return(max(x)-min(x))
}
Rango = round(apply(datos_quant, FUN = rango, MARGIN = 2), 3)
Minimo = round(apply(datos_quant, FUN = min, 2),3)
Maximo = round(apply(datos_quant, FUN = max, 2),3)
Desv = round(apply(datos_quant, FUN = sd, 2), 3)

tabla = data.frame(Unidad, Media, Desv, Minimo, Maximo, Rango)

tabla
```

- Datos cualitativos:

```{r, echo=FALSE}
summary(datos_qual)
```



## Análisis de normalidad multivariante

Con estos datos vamos a realizar nuestro estudio de normalidad multivariante.

Calculemos el vector de medias

```{r, echo = FALSE}
Medias = colMeans(datos_quant) # vector de medias

S = cov(datos_quant) # matriz de covarianza
```

y la distancia de Mahalanobis:

```{r}
d_Mahalanobis = apply(datos_quant, MARGIN = 1, function(x)
                    t(x - Medias)%*%solve(S)%*%(x - Medias))
```

Una vez calculadas estas medidas, representemos los datos

```{r, echo=FALSE}
plot(qchisq((1:nrow(datos_quant) - 1/2) / nrow(datos_quant), df = 3), sort(d_Mahalanobis), xlab = expression(paste("Cuantiles de la ", chi[20]^2)),ylab="Distancias ordenadas")
abline(a=0,b=1)
```
Notemos que no sigue una Chi-cuadrado, i por tanto los datos tampoco siguen una normal multivariante.

Vamos a realizar un test de normalidad para confirmarlo. Utilizaremos Shapiro-Wilk:

```{r}
mvnormtest::mshapiro.test(t(datos_quant))
```

Obtenemos un p-valor muy pequeño, prácticamente 0, entonces, rechazamos la hipótesis nula y concluimos que no hay normalidad multivariante, es decir, almenos una variable individual no se distribuye normalmente.


# Clusterning

En primer lugar vamos a tipificar o escalar nuestros datos para que esten todos a la misma escala:

```{r}
datos2 <- datos_quant %>% scale()
```

A continuación realicemos una representación gráfica de matrices de distancia:

Primero de todo vamos a centrar la matriz de datos:

```{r}
n <- dim(datos2)[1]
X <- as.matrix(datos2)
Hn <- diag(n)-1/n # matriz de centrado
cX <- Hn%*%X # matriz centrada
```


```{r}
mat_dist <- dist(x = cX, method = "euclidean")
```


```{r, cache = TRUE}
fviz_dist(dist.obj = mat_dist, lab_size = 5) +
 theme(legend.position = "none")
```
## K-means

En nuestro caso, no sabemos cuantos clusters o grupos esta dividido nuestro dataset. Por tanto vamos a estimar al número $k$ óptimo para aplicar el `kmeans()`. Para ello utilizaremos la función `fviz_nbclust()`:

```{r}
fviz_nbclust(x = cX, FUNcluster = kmeans, method = "wss",
 diss = dist(cX, method = "euclidean")) +
 geom_vline(xintercept = 3, linetype = 2)

```

Observemos que el número óptimo para aplicar el kmeans és $4$, ya que con $5$ el error aumenta y con $6$ el error es practicamente igual que con $4$. Por tanot procedamos a hacer un `kmeans()` con $k=4$:


```{r}
#set.seed(2312)
km_clusters <- kmeans(x = cX, centers = 3, nstart = 100)

fviz_cluster(object = km_clusters, data = cX, show.clust.cent = TRUE, geom ="point",
 ellipse.type = "euclid", star.plot = TRUE, repel = TRUE) +
theme_bw() +
theme(legend.position = "none")
```
Como nuestro número de variables (dimensionalidad) es mayor de 2, automáticamente
realiza un PCA y representa las dos primeras componentes principales (Dim1 y Dim2)


```{r}
km_clusters
```

## K-medoids (PAM)

En este caso, cada cluster está representado por una observación presente en el cluster (medoid), mientras que en K-means cada cluster está representado por su centroide,
que se corresponde con el promedio de todas las observaciones del cluster pero con ninguna en particular.

```{r, warning=FALSE}
fviz_nbclust(x = cX, FUNcluster = pam, method = "wss",
 diss = dist(datos, method = "manhattan"))+
  geom_vline(xintercept = 6, linetype = 2)
```


```{r}
pam_clusters <- pam(x = cX, k = 3, metric = "euclidean")

fviz_cluster(object = pam_clusters, data = cX, ellipse.type = "t", geom = "point",  repel = TRUE) +
  theme_bw() + 
  theme(legend.position = "none")
```
## Dendograma

```{r, cache =TRUE}
set.seed(101)
hc_completo <- datos_quant %>% scale() %>% dist(method = "euclidean") %>%
 hclust(method = "complete")
fviz_dend(x = hc_completo, k = 3, cex = 0.6) +
 geom_hline(yintercept = 5.5, linetype = "dashed")
```

